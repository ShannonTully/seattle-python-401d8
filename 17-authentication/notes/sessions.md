# CSRF Protection and Sessions
Cross Site Request Forgery is an attack vector commonly seen in web security. It depends on the fact that HTTP is stateless. And on the fact that it is hard to tell exactly where a request to your web app really comes from.

## How CSRF Attacks Work
Imagine that you are using your bank’s website to pay your bills. You have authenticated with the site, and so an authentication cookie is present in your browser. That cookie will be sent with any request that is sent to your bank’s site. Even if those requests come to the site by way of links from some other website.

Let’s further imagine that your bank’s website contains a form that allows you to transfer funds from one account to another. You enter the amount you want into a form text input named “amount”. And you select the destination account from a form select input named “destination_account_number”. Such a form might look like this:
```html
<form action="/transfer" method="POST">
  Amount: <input type="text" name="amount" value="0.00" />
  To Account:
  <select name="destination_account_number">
    <option value="1234567" selected>Savings Account</option>
    <option value="9876543">Checking Account</option>
  </select>
</form>
````
Now, let’s imagine further a malicious person who creates a website with a form that mimics this well-known structure. The form element need not be visible on the malicious web page. It can be submitted via javascript so that a visitor need only load the web page to submit the form. And it can be submitted in a way that leaves the malicious page showing. A visitor to this site would never know that such a submission was made.
```html
<form action="https://yourbank.com/transfer" method="POST" style="display: none;">
  <input type="text" name="amount" value="100.00" />
  <input type="text name="destination_account_number" value="5647382" />
</form>
```
Now, most users who visit this malicious site are not logged in to “yourbank.com”. For them, the request will result in an invisible, unreported 403 error. After all, your bank has properly ensured that you must be authenticated to submit POST requests to the transfer page. But you are authenticated and so when you click on a link to the malicious page, $100 is transfered out of your account and into the account identified in the malicious form.

## How to Prevent CSRF Attacks
CSRF attacks rely on the fact of persistent authentication, in combination with the inability of a site to ensure that the form that was submitted was in fact located in a page served by the bank’s website. To prevent this type of attack, we have to give our site the ability to make such a distinction.

In general, this is accomplished by generating a one-time value called a token when a visitor loads a page with a potentially vulnerable form. This token is rendered as a hidden input, and when the form is submitted, the value is present in the submitted form data. That incoming value is compared against a value stored on the server, and if it checks out then the form submission can proceed.

If it fails to check out, then the submission can be cancelled. The form that was submitted was not the form that was rendered previously, and an attack is underway.

This approach works quite well. Malicious sites are not able to produce the randomly generated values assigned as tokens. They might be able to copy generated by the protected site, but techniques for signing the produced tokens allow the protected site to distinguish between originals and copies that are used later.

But in order to use the technique, the token produced by the protected site must be persisted. The site has to be able to know which token it sent, so that it can compare it with the token received. And it has to do this on a per-visitor basis, since each visitor will receive a unique token.

In order to persist this value, the protected site must store the token on the server and be able to retrieve it when the same visitor makes a new request. We’ve seen how we can use cookies to persist data between requests. But if we were to use a cookie to store this data, we might take the chance that the information is stolen or duplicated. This would render our protection useless.

## Sessions
Instead, we can persist the token in a data structure held on the server. We can send an identifier for that data structure to the client in a cookie, and when a new request comes, we can retrieve the data structure and find the token so it can be compared.

Pyramid provides us with the ability to persist this data structure. It uses a mechanism called “sessions”. A session is a dictionary-like object that is usually stored on the server. An identifier is sent back to the client in a cookie, and when a new request is made, that same session object is found. We can use this to persist CSRF tokens sent with our forms, and when those forms are submitted, we can compare the incoming value against the value that was stored.

### _**Under circumstances requiring real security, this is not an acceptable implementation**_
